const puppeteer = require("puppeteer");
const axios = require("axios");
const fs = require("fs").promises;
const path = require("path");
const express = require("express");
const QRCode = require('qrcode');
const moment = require('moment-timezone');
const cloudinary = require('cloudinary').v2;
const ytdl = require('ytdl-core');
const { Client } = require('genius-lyrics');
require("dotenv").config();

// Kh·ªüi t·∫°o Express server
const app = express();
const port = 3000;

// Ph·ª•c v·ª• file HTML
app.get('/help', async (req, res) => {
  try {
    const htmlContent = await fs.readFile('help.html', 'utf8');
    res.send(htmlContent);
  } catch (error) {
    res.status(500).send('Error loading help page');
  }
});

// Kh·ªüi ƒë·ªông server
app.listen(port, () => {
  console.log(`üåê Help server running at http://localhost:${port}/help`);
});

// --- Game States ---
let activeGames = {
  tictactoe: {}, // {groupId: {board: [], currentPlayer: 'X', gameStarted: false}}
  quiz: {}, // {groupId: {question: '', answer: '', asked: false}}
  eightball: {} // {groupId: {lastQuestion: '', timestamp: 0}}
};

// Quiz questions database
const quizQuestions = [
  {
    question: "C·∫ßn bao nhi√™u vi√™n kim c∆∞∆°ng ƒë·ªÉ ch·∫ø t·∫°o m·ªôt b·ªô gi√°p ƒë·∫ßy ƒë·ªß?",
    answer: "24"
  },
  {
    question: "Creeper s·ª£ nh·∫•t lo√†i v·∫≠t n√†o?",
    answer: "m√®o"
  },
  {
    question: "Nether Portal c·∫ßn t·ªëi thi·ªÉu bao nhi√™u kh·ªëi Obsidian?",
    answer: "10"
  },
  {
    question: "Zombie c√≥ s·ª£ √°nh s√°ng m·∫∑t tr·ªùi kh√¥ng?",
    answer: "c√≥"
  },
  {
    question: "ƒê√™m trong Minecraft k√©o d√†i bao nhi√™u ph√∫t th·ª±c?",
    answer: "7"
  },
  {
    question: "C·∫ßn bao nhi√™u s·∫Øt ƒë·ªÉ ch·∫ø t·∫°o m·ªôt c√°i x√¥?",
    answer: "3"
  },
  {
    question: "Lo·∫°i g·ªó n√†o kh√¥ng t·ªìn t·∫°i trong Minecraft?",
    answer: "maple"
  },
  {
    question: "Enchantment n√†o d√πng ƒë·ªÉ th·ªü d∆∞·ªõi n∆∞·ªõc?",
    answer: "aqua affinity"
  }
];

// --- Configuration ---
// **QUAN TR·ªåNG:** ƒê·∫£m b·∫£o c√°c bi·∫øn m√¥i tr∆∞·ªùng n√†y ƒë∆∞·ª£c b·∫£o m·∫≠t!
const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY;
const GROUP_ID = process.env.GROUP_ID;
const FB_COOKIES_STRING = process.env.COOKIES; // Gi·ªØ d·∫°ng string tr∆∞·ªõc
const MY_USER_ID = process.env.MY_USER_ID; // L·∫•y t·ª´ gi√° tr·ªã c_user trong cookie
const HISTORY_FILE = "conversation_history.json";
const MAX_HISTORY_LENGTH = 50; // S·ªë l∆∞·ª£ng tin nh·∫Øn t·ªëi ƒëa l∆∞u tr·ªØ

// Th√™m bi·∫øn cho file l∆∞u tr·ªØ d·ªØ li·ªáu ng∆∞·ªùi d√πng
const USER_DATA_FILE = "user_data.json";

// Kh·ªüi t·∫°o Map ƒë·ªÉ l∆∞u d·ªØ li·ªáu ng∆∞·ªùi d√πng
let userData = new Map();

// H√†m t·∫£i d·ªØ li·ªáu ng∆∞·ªùi d√πng t·ª´ file
const loadUserData = async () => {
  try {
    const data = await fs.readFile(USER_DATA_FILE, 'utf8');
    const parsed = JSON.parse(data);
    userData = new Map(Object.entries(parsed));
    console.log(`üìö ƒê√£ t·∫£i d·ªØ li·ªáu c·ªßa ${userData.size} ng∆∞·ªùi d√πng`);
  } catch (error) {
    if (error.code === 'ENOENT') {
      console.log('üìù T·∫°o file d·ªØ li·ªáu ng∆∞·ªùi d√πng m·ªõi');
      await saveUserData();
    } else {
      console.error('‚ùå L·ªói khi ƒë·ªçc d·ªØ li·ªáu ng∆∞·ªùi d√πng:', error);
    }
  }
};

// H√†m l∆∞u d·ªØ li·ªáu ng∆∞·ªùi d√πng v√†o file
const saveUserData = async () => {
  try {
    const data = Object.fromEntries(userData);
    await fs.writeFile(USER_DATA_FILE, JSON.stringify(data, null, 2));
    console.log(`üíæ ƒê√£ l∆∞u d·ªØ li·ªáu c·ªßa ${userData.size} ng∆∞·ªùi d√πng`);
  } catch (error) {
    console.error('‚ùå L·ªói khi l∆∞u d·ªØ li·ªáu ng∆∞·ªùi d√πng:', error);
  }
};

// H√†m c·∫≠p nh·∫≠t XP cho ng∆∞·ªùi d√πng
const updateUserXP = async (userId) => {
  if (!userData.has(userId)) {
    userData.set(userId, {
      xp: 0,
      level: 1,
      messages: 0
    });
  }

  const user = userData.get(userId);
  const xpGain = Math.floor(Math.random() * 10) + 1; // 1-10 XP per message
  user.xp += xpGain;
  user.messages += 1;

  // Ki·ªÉm tra level up
  const nextLevel = Math.floor(Math.sqrt(user.xp / 100)) + 1;
  if (nextLevel > user.level) {
    user.level = nextLevel;
    await saveUserData();
    return createMessageBox(
      'üéâ LEVEL UP!',
      `Ch√∫c m·ª´ng! B·∫°n ƒë√£ ƒë·∫°t level ${user.level}!
XP hi·ªán t·∫°i: ${user.xp}
Tin nh·∫Øn: ${user.messages}`,
      'üí™ Ti·∫øp t·ª•c c·ªë g·∫Øng nh√©!'
    );
  }

  await saveUserData();
  return null;
};

// --- Input Validation ---
if (!OPENROUTER_API_KEY || !GROUP_ID || !FB_COOKIES_STRING || !MY_USER_ID) {
  console.error(
    "‚ùå L·ªói: Vui l√≤ng ki·ªÉm tra c√°c bi·∫øn m√¥i tr∆∞·ªùng OPENROUTER_API_KEY, GROUP_ID, COOKIES, MY_USER_ID trong file .env"
  );
  process.exit(1); // Tho√°t n·∫øu thi·∫øu config
}

let FB_COOKIES;
try {
  FB_COOKIES = JSON.parse(FB_COOKIES_STRING);
  if (!Array.isArray(FB_COOKIES)) throw new Error("Cookies kh√¥ng ph·∫£i l√† m·ªôt m·∫£ng JSON h·ª£p l·ªá.");
} catch (error) {
  console.error("‚ùå L·ªói ph√¢n t√≠ch COOKIES JSON:", error.message);
  process.exit(1);
}

// --- Constants ---
const FACEBOOK_URL = "https://www.facebook.com";
const MESSAGES_URL = `${FACEBOOK_URL}/messages/t/${GROUP_ID}`;

// *** SELECTORS ƒê√É C·∫¨P NH·∫¨T (D·ª±a tr√™n HTML b·∫°n cung c·∫•p) ***
// **C·∫¢NH B√ÅO:** C√°c selector n√†y V·∫™N c√≥ th·ªÉ thay ƒë·ªïi b·∫•t c·ª© l√∫c n√†o!
const MESSAGE_LIST_SELECTOR = 'div[role="log"]'; // V√πng ch·ª©a danh s√°ch tin nh·∫Øn (th∆∞·ªùng ·ªïn ƒë·ªãnh h∆°n)
const MESSAGE_ROW_SELECTOR = 'div[role="gridcell"]'; // Selector cho t·ª´ng d√≤ng tin nh·∫Øn (c√≥ th·ªÉ c·∫ßn ƒëi·ªÅu ch·ªânh)
const MESSAGE_TEXT_SELECTOR = 'div[dir="auto"]'; // Selector l·∫•y n·ªôi dung text (ph·ª©c t·∫°p h∆°n ƒë·ªÉ l·∫•y ƒë√∫ng text)
const INPUT_BOX_SELECTOR = 'div[role="textbox"][contenteditable="true"][aria-label*="Tin nh·∫Øn"]'; // Selector √¥ nh·∫≠p li·ªáu (n√™n d√πng aria-label cho ·ªïn ƒë·ªãnh)

const CHECK_INTERVAL_MS = 5000; // 5 gi√¢y
const TYPE_DELAY_MS = 50; // Delay gi·ªØa c√°c l·∫ßn g√µ ph√≠m
const SEND_DELAY_MS = 1000; // Delay tr∆∞·ªõc khi g·ª≠i tin nh·∫Øn

// --- Constants & Config ---
const MAX_CONTEXT_LENGTH = 10;
let conversationHistory = [];

// C·∫≠p nh·∫≠t danh s√°ch emoji ƒë∆°n gi·∫£n v√† ch·∫Øc ch·∫Øn hi·ªÉn th·ªã ƒë∆∞·ª£c
const EMOJI_THEMES = {
  positive: ['üòä', 'üòÑ', 'üòÅ', 'üòÉ', 'üòÄ'],
  negative: ['üò¢', 'üò≠', 'üòû', 'üòî', 'üòï'],
  funny: ['üòÇ', 'ü§£', 'üòÖ', 'üòÜ', 'üòù'],
  gaming: ['üòé', 'üëæ', 'üéÆ', 'üé≤', 'üéØ'],
  thinking: ['ü§î', 'üôÑ', 'üòè', 'üòå', 'üßê'],
  love: ['‚ù§Ô∏è', 'üíï', 'üíó', 'üíì', 'üíñ'],
  food: ['üòã', 'üçï', 'üçî', 'üçü', 'üç™'],
  music: ['üéµ', 'üé∂', 'üé∏', 'üé§', 'üéº'],
  nature: ['üå∏', 'üå∫', 'üåº', 'üåª', 'üåπ'],
  tech: ['üíª', 'üì±', 'üîå', 'üí°', 'üì∂']
};

// C·∫≠p nh·∫≠t h√†m ch·ªçn emoji
const getContextualEmojis = (text) => {
  text = text.toLowerCase();
  let selectedEmojis = [];

  // Ch·ªçn ch·ªß ƒë·ªÅ d·ª±a tr√™n n·ªôi dung
  if (text.match(/(haha|lol|c∆∞·ªùi|vui|funny|joke)/)) {
    selectedEmojis = EMOJI_THEMES.funny;
  }
  else if (text.match(/(game|ch∆°i|play|minecraft)/)) {
    selectedEmojis = EMOJI_THEMES.gaming;
  }
  else if (text.match(/(love|y√™u|th∆∞∆°ng|crush)/)) {
    selectedEmojis = EMOJI_THEMES.love;
  }
  else if (text.match(/(bu·ªìn|kh√≥c|sad|huhu)/)) {
    selectedEmojis = EMOJI_THEMES.negative;
  }
  else {
    selectedEmojis = EMOJI_THEMES.positive;
  }

  // Ch·ªâ ch·ªçn 2 emoji ng·∫´u nhi√™n
  const result = [];
  for (let i = 0; i < 2; i++) {
    const randomIndex = Math.floor(Math.random() * selectedEmojis.length);
    result.push(selectedEmojis[randomIndex]);
  }
  
  return result.join('');
};

// H√†m ƒë·ªçc l·ªãch s·ª≠ h·ªôi tho·∫°i t·ª´ file
const loadConversationHistory = async () => {
  try {
    const data = await fs.readFile(HISTORY_FILE, 'utf8');
    conversationHistory = JSON.parse(data);
    console.log(`üìö ƒê√£ t·∫£i ${conversationHistory.length} tin nh·∫Øn t·ª´ l·ªãch s·ª≠`);
  } catch (error) {
    if (error.code === 'ENOENT') {
      console.log('üìù T·∫°o file l·ªãch s·ª≠ h·ªôi tho·∫°i m·ªõi');
      await saveConversationHistory();
    } else {
      console.error('‚ùå L·ªói khi ƒë·ªçc l·ªãch s·ª≠:', error);
    }
  }
};

// H√†m l∆∞u l·ªãch s·ª≠ h·ªôi tho·∫°i v√†o file
const saveConversationHistory = async () => {
  try {
    await fs.writeFile(HISTORY_FILE, JSON.stringify(conversationHistory, null, 2));
    console.log(`üíæ ƒê√£ l∆∞u ${conversationHistory.length} tin nh·∫Øn v√†o l·ªãch s·ª≠`);
  } catch (error) {
    console.error('‚ùå L·ªói khi l∆∞u l·ªãch s·ª≠:', error);
  }
};

// Th√™m tin nh·∫Øn v√†o context v√† l∆∞u v√†o file
const addToContext = async (role, content) => {
  const message = { role, content, timestamp: Date.now() };
  conversationHistory.push(message);

  // Gi·ªØ context trong gi·ªõi h·∫°n
  if (conversationHistory.length > MAX_HISTORY_LENGTH) {
    conversationHistory = conversationHistory.slice(-MAX_HISTORY_LENGTH);
  }

  // L∆∞u v√†o file
  await saveConversationHistory();
};

// H√†m l·∫•y context li√™n quan
const getRelevantContext = (userInput) => {
  // L·ªçc tin nh·∫Øn trong v√≤ng 24h g·∫ßn nh·∫•t
  const last24Hours = Date.now() - (24 * 60 * 60 * 1000);
  return conversationHistory
    .filter(msg => msg.timestamp > last24Hours)
    .slice(-10); // L·∫•y 10 tin nh·∫Øn g·∫ßn nh·∫•t
};

// H√†m l√†m s·∫°ch text t·ª´ messenger
const cleanMessengerText = (text) => {
  if (!text) return '';
  try {
    // Decode HTML entities n·∫øu c√≥
    text = text.replace(/&amp;/g, '&')
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/&#x2F;/g, '/');

    // Chu·∫©n h√≥a unicode
    text = text.normalize('NFKC');

    // Lo·∫°i b·ªè c√°c k√Ω t·ª± ƒë·∫∑c bi·ªát nh∆∞ng gi·ªØ l·∫°i unicode ti·∫øng Vi·ªát
    text = text.replace(/[\u0000-\u001F\u007F-\u009F]/g, '')
      .replace(/[^\p{L}\p{N}\p{P}\p{Z}]/gu, ' ')
      .trim();

    // Lo·∫°i b·ªè kho·∫£ng tr·∫Øng th·ª´a
    text = text.replace(/\s+/g, ' ');

    return text;
  } catch (error) {
    console.error('‚ùå L·ªói khi l√†m s·∫°ch text:', error);
    return text;
  }
};

// Ki·ªÉm tra tin nh·∫Øn c√≥ h·ª£p l·ªá kh√¥ng
const isValidMessage = (text) => {
  if (!text) return false;
  const cleanedText = cleanMessengerText(text);
  // Ki·ªÉm tra ƒë·ªô d√†i t·ªëi thi·ªÉu v√† c√≥ k√Ω t·ª± h·ª£p l·ªá
  return cleanedText.length >= 2 && /[\p{L}]/u.test(cleanedText);
};

// C·∫≠p nh·∫≠t h√†m format tin nh·∫Øn
const formatMessage = (text) => {
  // N·∫øu text ch·ª©a URL, tr·∫£ v·ªÅ nguy√™n b·∫£n kh√¥ng th√™m zero-width space
  if (text.includes('http://') || text.includes('https://')) {
    return text;
  }
  // Th√™m zero-width space sau m·ªói k√Ω t·ª± ƒë·∫∑c bi·ªát cho text kh√¥ng ch·ª©a URL
  return text.replace(/([!@#$%^&*(),.?":{}|<>])/g, '$1\u200B');
};

// --- Helper Functions ---
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// üß† G·ªçi AI qua OpenRouter API
const callAI = async (userInput) => {
  console.log("‚úâÔ∏è G·ª≠i AI:", userInput);
  const MODEL_NAME = "google/gemini-pro";
  const API_ENDPOINT = "https://openrouter.ai/api/v1/chat/completions";

  try {
    const relevantContext = getRelevantContext(userInput);
    await addToContext("user", userInput);

    const systemPrompt = {
      role: "system",
      content: `B·∫°n l√† m·ªôt bot chat th√¥ng minh v√† h√†i h∆∞·ªõc trong nh√≥m chat messenger. H√£y:
- Tr·∫£ l·ªùi ng·∫Øn g·ªçn trong 1-2 c√¢u
- S·ª≠ d·ª•ng ng√¥n ng·ªØ GenZ ƒë∆°n gi·∫£n v√† d·ªÖ hi·ªÉu
- T·∫≠p trung v√†o tr·ªçng t√¢m c√¢u h·ªèi
- Ch·ªâ d√πng emoji c∆° b·∫£n v√† ph·ªï bi·∫øn
- Gi·ªØ gi·ªçng ƒëi·ªáu vui v·∫ª v√† th√¢n thi·ªán
- C√≥ th·ªÉ ƒë√πa nh·∫π nh√†ng khi ph√π h·ª£p
- Tr√°nh lan man v√† d√†i d√≤ng
- LU√îN tr·∫£ l·ªùi b·∫±ng Ti·∫øng Vi·ªát c√≥ d·∫•u`
    };

    const res = await axios.post(
      API_ENDPOINT,
      {
        model: MODEL_NAME,
        messages: [
          systemPrompt,
          ...relevantContext,
          { role: "user", content: userInput }
        ],
        max_tokens: 150,
        temperature: 0.9,
        presence_penalty: 0.8,
        frequency_penalty: 0.8,
        stream: false
      },
      {
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${OPENROUTER_API_KEY}`,
          "HTTP-Referer": "https://github.com",
          "X-Title": "FB Messenger Bot"
        },
        timeout: 30000,
      }
    );

    let text = res.data.choices?.[0]?.message?.content;
    if (!text) {
      text = res.data.choices?.[0]?.text;
    }

    if (text && isValidMessage(text)) {
      text = cleanMessengerText(text);
      await addToContext("assistant", text);

      // Th√™m emoji ƒë∆°n gi·∫£n
      const contextualEmojis = getContextualEmojis(text + " " + userInput);
      text = `${contextualEmojis} ${text}`;

      console.log(`ü§ñ AI tr·∫£ l·ªùi:`, text);
      return text;
    } else {
      console.warn(`‚ö†Ô∏è AI tr·∫£ v·ªÅ n·ªôi dung kh√¥ng h·ª£p l·ªá:`, text);
      throw new Error("Invalid response from AI");
    }
  } catch (err) {
    console.error("DEBUG: Full error:", err);
    const errorMessage = err?.response?.data?.error?.message || err?.response?.data || err.message;
    const errorStatus = err?.response?.status;
    console.error(`‚ùå OpenRouter Error (Status: ${errorStatus}):`, errorMessage);

    // X√≥a tin nh·∫Øn l·ªói kh·ªèi context
    conversationHistory.pop();

    if (errorStatus === 401) return "üò¢ Ui, API key kh√¥ng ƒë√∫ng r·ªìi!";
    if (errorStatus === 402) return "üòÖ H·∫øt ti·ªÅn r·ªìi, n·∫°p th√™m credits ƒëi b·∫°n ∆°i!";
    if (errorStatus === 429) return "ü•µ Ngh·ªâ x√≠u nha, m√¨nh ƒëang h∆°i qu√° t·∫£i!";
    if (errorStatus === 500 || errorStatus === 503) return `üò¥ Server ƒëang ng·ªß, l√°t n·ªØa th·ª≠ l·∫°i nha!`;
    return `ü§î Oops, c√≥ g√¨ ƒë√≥ sai sai. Th·ª≠ l·∫°i nha!`;
  }
};

// üí¨ G·ª≠i tin nh·∫Øn trong chat
const sendMessage = async (page, message) => {
  try {
    if (!isValidMessage(message)) {
      console.warn("‚ö†Ô∏è Tin nh·∫Øn kh√¥ng h·ª£p l·ªá, b·ªè qua");
      return false;
    }

    message = cleanMessengerText(message);
    if (message.length < 2) {
      console.warn("‚ö†Ô∏è Tin nh·∫Øn qu√° ng·∫Øn sau khi l√†m s·∫°ch, b·ªè qua");
      return false;
    }

    // Format tin nh·∫Øn tr∆∞·ªõc khi th√™m prefix
    message = formatMessage(message);
    
    // Th√™m ƒë·ªãnh d·∫°ng font ch·ªØ
    message = `${message}`;

    const MAX_LENGTH = 500;
    const messageParts = [];
    for (let i = 0; i < message.length; i += MAX_LENGTH) {
      messageParts.push(message.substring(i, i + MAX_LENGTH));
    }

    for (const part of messageParts) {
      await page.waitForSelector(INPUT_BOX_SELECTOR, { timeout: 10000 });
      await page.click(INPUT_BOX_SELECTOR);
      await delay(200);

      // S·ª≠ d·ª•ng contentEditable ƒë·ªÉ gi·ªØ nguy√™n format
      await page.evaluate((text) => {
        const el = document.querySelector('div[role="textbox"]');
        if (el) {
          el.innerHTML = '';
          el.focus();
          // S·ª≠ d·ª•ng execCommand ƒë·ªÉ paste text v·ªõi format
          document.execCommand('insertText', false, text);
        }
      }, part);

      await delay(SEND_DELAY_MS);
      await page.keyboard.press("Enter");
      console.log("‚úÖ ƒê√£ g·ª≠i tin nh·∫Øn:", part);
      await delay(1500);
    }
    return true;
  } catch (error) {
    console.error(`‚ùå L·ªói khi g·ª≠i tin nh·∫Øn:`, error.message);
    try {
      await page.screenshot({ path: `error_send_message_${Date.now()}.png` });
    } catch (screenshotError) {
      console.error("‚ùå Kh√¥ng th·ªÉ ch·ª•p ·∫£nh m√†n h√¨nh:", screenshotError.message);
    }
    return false;
  }
};

// --- Main Logic ---
(async () => {
  let browser = null;
  try {
    // T·∫£i l·ªãch s·ª≠ h·ªôi tho·∫°i khi kh·ªüi ƒë·ªông
    await loadConversationHistory();

    console.log("üöÄ Kh·ªüi ƒë·ªông tr√¨nh duy·ªát...");
    browser = await puppeteer.launch({
      headless: "new",
      args: [
        "--no-sandbox",
        "--disable-setuid-sandbox",
        "--disable-notifications",
        "--mute-audio",
        '--disable-gpu',
        '--window-size=1280,800',
        '--disable-dev-shm-usage',
        '--single-process'
      ],
      executablePath: process.env.PUPPETEER_EXECUTABLE_PATH || null,
      userDataDir: './browser_data'
    });

    const page = await browser.newPage();
    await page.setViewport({ width: 1280, height: 800 });

    console.log("üîë ƒêang ƒë·∫∑t cookies...");
    await page.setCookie(...FB_COOKIES);

    console.log(`üåê ƒêang truy c·∫≠p ${FACEBOOK_URL}...`);
    await page.goto(FACEBOOK_URL, { waitUntil: "networkidle2", timeout: 60000 });

    if (page.url().includes("/login") || await page.$('form#login_form') || await page.$('[data-testid="royal_login_button"]')) {
      console.error("üîí ƒêƒÉng nh·∫≠p th·∫•t b·∫°i! Cookie sai, h·∫øt h·∫°n ho·∫∑c c·∫ßn x√°c th·ª±c 2 y·∫øu t·ªë.");
      await page.screenshot({ path: 'error_login_page.png' }); // Ch·ª•p ·∫£nh m√†n h√¨nh trang login
      console.log("üì∏ ƒê√£ ch·ª•p ·∫£nh m√†n h√¨nh l·ªói ƒëƒÉng nh·∫≠p.");
      await browser.close();
      return;
    }
    console.log("‚úÖ ƒêƒÉng nh·∫≠p th√†nh c√¥ng!");

    console.log(`üí¨ ƒêang truy c·∫≠p nh√≥m chat ${GROUP_ID}...`);
    await page.goto(MESSAGES_URL, { waitUntil: "networkidle2", timeout: 60000 });

    try {
      // Ch·ªù c·∫£ √¥ nh·∫≠p li·ªáu v√† danh s√°ch tin nh·∫Øn xu·∫•t hi·ªán
      await Promise.all([
        page.waitForSelector(INPUT_BOX_SELECTOR, { timeout: 30000 }),
        page.waitForSelector(MESSAGE_ROW_SELECTOR, { timeout: 30000 }) // Ch·ªù c·∫£ d√≤ng tin nh·∫Øn ƒë·∫ßu ti√™n
      ]);
      console.log("ü§ñ ƒê√£ v√†o nh√≥m chat. B·∫Øt ƒë·∫ßu theo d√µi tin nh·∫Øn...");
    } catch (error) {
      console.error(`‚ùå Kh√¥ng t√¨m th·∫•y th√†nh ph·∫ßn c·∫ßn thi·∫øt trong nh√≥m chat (${INPUT_BOX_SELECTOR} ho·∫∑c ${MESSAGE_ROW_SELECTOR}). Ki·ªÉm tra l·∫°i GROUP_ID ho·∫∑c selectors.`);
      await page.screenshot({ path: `error_group_load_${Date.now()}.png` });
      console.log("üì∏ ƒê√£ ch·ª•p ·∫£nh m√†n h√¨nh l·ªói t·∫£i nh√≥m chat.");
      await browser.close();
      return;
    }

    let lastProcessedMessageId = null;
    let lastSentMessageText = "";

    const messageProcessingInterval = setInterval(async () => {
      try {
        console.log("DEBUG: Interval tick - Checking for messages...");

        const messagesData = await page.evaluate((rowSelector, textSelector) => {
          const messageRows = Array.from(document.querySelectorAll(rowSelector)).slice(-10);
          return messageRows.map(row => {
            const textElements = Array.from(row.querySelectorAll(textSelector));
            // L·∫•y text t·ª´ element cu·ªëi c√πng v√† l√†m s·∫°ch
            let text = textElements[textElements.length - 1]?.innerText || '';

            // T·∫°o ID duy nh·∫•t cho tin nh·∫Øn
            const timestamp = Date.now();
            const randomId = Math.random().toString(36).substring(7);
            const messageId = `msg_${timestamp}_${randomId}`;

            return {
              id: messageId,
              text: text.trim(),
              timestamp: timestamp
            };
          }).filter(msg => msg.text);
        }, MESSAGE_ROW_SELECTOR, MESSAGE_TEXT_SELECTOR);

        console.log("DEBUG: Fetched messagesData count:", messagesData.length);
        if (messagesData.length > 0) {
          console.log("DEBUG: Last message data:", messagesData[messagesData.length - 1]);
        }

        if (!messagesData.length) return;

        const lastMessage = messagesData[messagesData.length - 1];
        const cleanedText = cleanMessengerText(lastMessage.text);

        console.log("DEBUG: lastMessage.id:", lastMessage.id);
        console.log("DEBUG: lastProcessedMessageId:", lastProcessedMessageId);
        console.log("DEBUG: Cleaned message text:", cleanedText);
        console.log("DEBUG: lastSentMessageText:", lastSentMessageText ? lastSentMessageText.substring(0, 50) + "..." : "null");

        // Ki·ªÉm tra v√† x·ª≠ l√Ω tin nh·∫Øn
        if (lastMessage.id === lastProcessedMessageId ||
          cleanedText === lastSentMessageText ||
          !isValidMessage(cleanedText)) {
          console.log("DEBUG: Skipping - Message already processed or invalid");
          return;
        }

        // X·ª≠ l√Ω l·ªánh
        if (cleanedText.startsWith("!")) {
          console.log(`üì¨ Nh·∫≠n ƒë∆∞·ª£c l·ªánh: ${cleanedText}`);
          const command = cleanedText.toLowerCase();

          let reply = "";
          if (command === "!help") {
            reply = handleHelp();
          } else if (command === "!tictactoe") {
            reply = handleTicTacToe(GROUP_ID, null, lastMessage.id.split("_")[2]);
          } else if (command.startsWith("!tictactoe ")) {
            const position = cleanedText.slice(10).trim();
            reply = handleTicTacToe(GROUP_ID, position, lastMessage.id.split("_")[2]);
          } else if (command === "!quiz") {
            reply = handleQuiz(GROUP_ID);
          } else if (command === "!roll") {
            reply = handleRoll();
          } else if (command.startsWith("!8ball ")) {
            const question = cleanedText.slice(7).trim();
            reply = handle8Ball(question);
          } else if (command === "!info") {
            reply = handleInfo();
          } else if (command === "!rule") {
            reply = handleRule();
          } else if (command === "!rank") {
            reply = handleRank(lastMessage.id.split("_")[2]);
          } else if (command === "!top") {
            reply = handleTop();
          } else if (command.startsWith("!play ")) {
            const url = cleanedText.slice(6).trim();
            try {
              reply = await handleMusic(GROUP_ID, url);
            } catch (err) {
              reply = createMessageBox('‚ùå L·ªñI', 'L·ªói khi x·ª≠ l√Ω b√†i h√°t!');
            }
          } else if (command.startsWith("!lyrics ")) {
            const song = cleanedText.slice(8).trim();
            reply = await searchLyrics(song);
          } else if (command === "!sticker") {
            if (lastMessage.attachments && lastMessage.attachments.length > 0) {
              reply = await createSticker(lastMessage.attachments[0].url);
            } else {
              reply = createMessageBox('‚ùå L·ªñI', 'Vui l√≤ng g·ª≠i k√®m m·ªôt ·∫£nh!');
            }
          } else if (command.startsWith("!qr ")) {
            const text = cleanedText.slice(4).trim();
            reply = await handleQR(text);
          } else if (command.startsWith("!mcskin ")) {
            const username = cleanedText.slice(8).trim();
            reply = handleMCSkin(username);
          } else if (command.startsWith("!mcmob ")) {
            const mobName = cleanedText.slice(7).trim();
            reply = handleMCMob(mobName);
          } else if (command.startsWith("!mcblock ")) {
            const blockName = cleanedText.slice(9).trim();
            reply = handleMCBlock(blockName);
          } else if (command === "!mcmeme") {
            reply = handleMCMeme();
          } else if (command === "!mcmusic") {
            reply = handleMCMusic();
          } else {
            const question = cleanedText.slice(1).trim();
            if (question.length < 2) {
              console.log("‚ö†Ô∏è C√¢u h·ªèi qu√° ng·∫Øn, b·ªè qua.");
              lastProcessedMessageId = lastMessage.id;
              return;
            }

            console.log("DEBUG: Sending question to AI:", question);
            reply = await callAI(question);
          }

          if (reply) {
            const success = await sendMessage(page, reply);
            if (success) {
              lastSentMessageText = reply;
              lastProcessedMessageId = lastMessage.id;
            }
          }
        }

        // C·∫≠p nh·∫≠t XP cho ng∆∞·ªùi d√πng
        const userId = lastMessage.id.split("_")[2];
        if (userId && !userData.has(userId)) {
          userData.set(userId, {
            xp: 0,
            level: 1,
            messages: 0
          });
          await saveUserData();
        }

      } catch (e) {
        console.error("‚ùå L·ªói trong v√≤ng l·∫∑p theo d√µi:", e);
        // Ki·ªÉm tra tr·∫°ng th√°i trang
        try {
          if (!browser || !browser.isConnected()) {
            console.error("‚ò†Ô∏è Tr√¨nh duy·ªát ƒë√£ m·∫•t k·∫øt n·ªëi! D·ª´ng bot.");
            clearInterval(messageProcessingInterval);
            process.exit(1);
          }
          const currentUrl = page.url();
          if (currentUrl.includes("/login") || await page.$('form#login_form')) {
            console.error("‚ò†Ô∏è B·ªã ƒëƒÉng xu·∫•t gi·ªØa ch·ª´ng! D·ª´ng bot.");
            await page.screenshot({ path: `error_logged_out_${Date.now()}.png` });
            console.log("üì∏ ƒê√£ ch·ª•p ·∫£nh m√†n h√¨nh b·ªã ƒëƒÉng xu·∫•t.");
            clearInterval(messageProcessingInterval);
            if (browser) await browser.close();
            process.exit(1);
          }
          if (!await page.$(INPUT_BOX_SELECTOR)) {
            console.error("‚ò†Ô∏è Kh√¥ng t√¨m th·∫•y √¥ nh·∫≠p li·ªáu n·ªØa! Trang c√≥ th·ªÉ ƒë√£ b·ªã l·ªói. Th·ª≠ reload...");
            await page.reload({ waitUntil: "networkidle2", timeout: 60000 });
            await Promise.all([
              page.waitForSelector(INPUT_BOX_SELECTOR, { timeout: 30000 }),
              page.waitForSelector(MESSAGE_ROW_SELECTOR, { timeout: 30000 })
            ]);
            console.log("üîÑ ƒê√£ reload trang v√† t√¨m th·∫•y l·∫°i c√°c th√†nh ph·∫ßn.");
          }

        } catch (checkError) {
          console.error("‚ùå L·ªói nghi√™m tr·ªçng khi ki·ªÉm tra tr·∫°ng th√°i page ho·∫∑c reload:", checkError.message);
          clearInterval(messageProcessingInterval);
          if (browser) {
            await browser.close();
          }
          process.exit(1);
        }
      }
    }, CHECK_INTERVAL_MS);

    console.log("‚ú® Bot ƒëang ch·∫°y. Nh·∫•n Ctrl+C ƒë·ªÉ d·ª´ng.");
    await new Promise(() => { });

  } catch (error) {
    console.error("‚ùå L·ªói kh·ªüi ƒë·ªông:", error);
    if (browser) await browser.close();
    process.exit(1);
  }
})();

// X·ª≠ l√Ω khi nh·∫•n Ctrl+C
process.on('SIGINT', async () => {
  console.log("\nüõë Nh·∫≠n ƒë∆∞·ª£c t√≠n hi·ªáu d·ª´ng (Ctrl+C). ƒêang ƒë√≥ng tr√¨nh duy·ªát...");
  console.log("üëã T·∫°m bi·ªát!");
  process.exit(0);
});

// Kh·ªüi t·∫°o c√°c bi·∫øn cho ch·ª©c nƒÉng m·ªõi
let musicQueue = new Map();
let userLevels = new Map();
let gameStates = new Map();

// H√†m l·∫•y th·ªùi ti·∫øt
const getWeather = (city) => {
  return new Promise((resolve, reject) => {
    weather.find({ search: city, degreeType: 'C' }, (err, result) => {
      if (err) reject(err);
      resolve(result);
    });
  });
};

// H√†m t·∫°o QR code
const generateQR = async (text) => {
  try {
    return await QRCode.toDataURL(text);
  } catch (err) {
    console.error('L·ªói t·∫°o QR:', err);
    return null;
  }
};

// H√†m t√¨m ki·∫øm Wikipedia
const searchWiki = async (query, lang = 'vi') => {
  try {
    const response = await fetch(`https://${lang}.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(query)}`);
    const data = await response.json();
    return data.extract;
  } catch (err) {
    console.error('L·ªói t√¨m Wikipedia:', err);
    return null;
  }
};

// H√†m t·∫°o khung tin nh·∫Øn ƒë·∫πp
const createMessageBox = (title, content, footer = '') => {
  const width = 35;
  const line = '‚ïê'.repeat(width);
  const space = ' '.repeat(width);
  
  let box = `‚ïî${line}‚ïó\n`;
  box += `‚ïë${space}‚ïë\n`;
  
  // Title
  const paddedTitle = title.padStart((width + title.length) / 2).padEnd(width);
  box += `‚ïë${paddedTitle}‚ïë\n`;
  box += `‚ïë${space}‚ïë\n`;
  
  // Content
  const lines = content.split('\n');
  for (const line of lines) {
    const paddedLine = line.padEnd(width);
    box += `‚ïë${paddedLine}‚ïë\n`;
  }
  
  // Footer
  if (footer) {
    box += `‚ïë${space}‚ïë\n`;
    const paddedFooter = footer.padStart((width + footer.length) / 2).padEnd(width);
    box += `‚ïë${paddedFooter}‚ïë\n`;
  }
  
  box += `‚ïë${space}‚ïë\n`;
  box += `‚ïö${line}‚ïù`;
  
  return box;
};

// H√†m t·∫°o b·∫£ng x·∫øp h·∫°ng ƒë·∫πp
const createLeaderboard = (title, entries) => {
  const width = 35;
  const line = '‚îÄ'.repeat(width - 2);
  
  let board = `‚îå${line}‚îê\n`;
  board += `‚îÇ ${title.padEnd(width - 3)}‚îÇ\n`;
  board += `‚îú${line}‚î§\n`;
  
  for (const [index, entry] of entries.entries()) {
    const rank = `${index + 1}`.padStart(2);
    const text = entry.padEnd(width - 6);
    board += `‚îÇ ${rank}. ${text}‚îÇ\n`;
  }
  
  board += `‚îî${line}‚îò`;
  
  return board;
};

// H√†m t·∫°o menu tr·ª£ gi√∫p
const createHelpMenu = () => {
  return createMessageBox(
    'üéÆ MINECRAFT BOT COMMANDS',
    `Game Commands:
!mcskin [t√™n] - Xem skin
!mcmob [t√™n] - Xem mob
!mcblock [t√™n] - Xem block
!mcmeme - Xem meme
!mcmusic - Nghe nh·∫°c
!tictactoe - Ch∆°i c·ªù caro
!quiz - C√¢u ƒë·ªë Minecraft
!roll - Tung x√∫c x·∫Øc
!8ball - B√≥i to√°n vui

Nh√≥m Commands:
!info - Th√¥ng tin nh√≥m
!rule - N·ªôi quy nh√≥m
!rank - Xem c·∫•p ƒë·ªô
!top - B·∫£ng x·∫øp h·∫°ng

Ti·ªán √≠ch:
!play [url] - Th√¥ng tin nh·∫°c
!lyrics [t√™n] - L·ªùi b√†i h√°t
!sticker - T·∫°o sticker
!qr [text] - T·∫°o m√£ QR`,
    'üí° G√µ l·ªánh ƒë·ªÉ b·∫Øt ƒë·∫ßu!'
  );
};

// H√†m t·∫°o b·∫£ng c·ªù caro ƒë·∫πp
const renderBoard = (board) => {
  const symbols = {
    X: '‚ùå',
    O: '‚≠ï',
    null: '  '
  };
  
  let result = '```\n';
  result += '‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê\n';
  for (let i = 0; i < 9; i += 3) {
    result += `‚îÇ ${symbols[board[i]] || ' '} ‚îÇ ${symbols[board[i+1]] || ' '} ‚îÇ ${symbols[board[i+2]] || ' '} ‚îÇ\n`;
    if (i < 6) result += '‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚î§\n';
  }
  result += '‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò\n';
  result += '```';
  return result;
};

// C·∫≠p nh·∫≠t h√†m x·ª≠ l√Ω ph√°t nh·∫°c v·ªõi giao di·ªán ƒë·∫πp
const handleMusic = async (groupId, url) => {
  try {
    const info = await ytdl.getInfo(url);
    const duration = `${Math.floor(info.videoDetails.lengthSeconds / 60)}:${(info.videoDetails.lengthSeconds % 60).toString().padStart(2, '0')}`;
    
    return createMessageBox(
      'üéµ TH√îNG TIN B√ÄI H√ÅT',
      `T√™n: ${info.videoDetails.title}
K√™nh: ${info.videoDetails.author.name}
Th·ªùi l∆∞·ª£ng: ${duration}
L∆∞·ª£t xem: ${info.videoDetails.viewCount.toLocaleString()}

${info.videoDetails.description.slice(0, 100)}...`,
      `üîó ${url}`
    );
  } catch (error) {
    console.error("L·ªói x·ª≠ l√Ω nh·∫°c:", error);
    return createMessageBox('‚ùå L·ªñI', 'Kh√¥ng th·ªÉ l·∫•y th√¥ng tin b√†i h√°t n√†y!');
  }
};

// C·∫≠p nh·∫≠t h√†m x·ª≠ l√Ω lyrics v·ªõi giao di·ªán ƒë·∫πp
const searchLyrics = async (query) => {
  try {
    const searches = await genius.songs.search(query);
    if (searches.length > 0) {
      const song = searches[0];
      return createMessageBox(
        'üéµ TH√îNG TIN B√ÄI H√ÅT',
        `T√™n: ${song.title}
Ca sƒ©: ${song.artist}
Album: ${song.album || 'N/A'}`,
        `üîó ${song.url}`
      );
    }
    return createMessageBox('‚ùå KH√îNG T√åM TH·∫§Y', 'Kh√¥ng t√¨m th·∫•y th√¥ng tin b√†i h√°t!');
  } catch (err) {
    console.error('L·ªói t√¨m l·ªùi b√†i h√°t:', err);
    return createMessageBox('‚ùå L·ªñI', 'ƒê√£ x·∫£y ra l·ªói khi t√¨m ki·∫øm!');
  }
};

// C·∫≠p nh·∫≠t h√†m x·ª≠ l√Ω rank v·ªõi giao di·ªán ƒë·∫πp
const handleRank = (userId) => {
  if (!userData.has(userId)) {
    return createMessageBox(
      'üìä TH√îNG TIN C·∫§P ƒê·ªò',
      'B·∫°n ch∆∞a c√≥ c·∫•p ƒë·ªô n√†o!\nH√£y t√≠ch c·ª±c tham gia tr√≤ chuy·ªán!',
      'üí° G·ª≠i tin nh·∫Øn ƒë·ªÉ nh·∫≠n XP'
    );
  }

  const user = userData.get(userId);
  const nextLevelXP = (user.level + 1) * (user.level + 1) * 100;
  
  return createMessageBox(
    'üìä TH√îNG TIN C·∫§P ƒê·ªò',
    `C·∫•p ƒë·ªô: ${user.level}
Kinh nghi·ªám: ${user.xp}/${nextLevelXP}
Tin nh·∫Øn: ${user.messages}

C·∫ßn th√™m ${nextLevelXP - user.xp} XP ƒë·ªÉ l√™n c·∫•p!`,
    'üí™ C·ªë l√™n n√†o!'
  );
};

// C·∫≠p nh·∫≠t h√†m x·ª≠ l√Ω top v·ªõi giao di·ªán ƒë·∫πp
const handleTop = () => {
  const sortedUsers = Array.from(userData.entries())
    .sort(([, a], [, b]) => b.xp - a.xp)
    .slice(0, 5)
    .map(([userId, user], index) => {
      const crown = index === 0 ? 'üëë' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : 'üéÆ';
      return `${crown} Lv.${user.level} - ${user.xp}XP - ${user.messages} tin`;
    });

  if (sortedUsers.length === 0) {
    return createMessageBox(
      'üèÜ B·∫¢NG X·∫æP H·∫†NG',
      'Ch∆∞a c√≥ ai trong b·∫£ng x·∫øp h·∫°ng!\nH√£y l√† ng∆∞·ªùi ƒë·∫ßu ti√™n nh√©!',
      'üí° G·ª≠i tin nh·∫Øn ƒë·ªÉ g√≥p m·∫∑t'
    );
  }

  return createLeaderboard('üèÜ B·∫¢NG X·∫æP H·∫†NG', sortedUsers);
};

// C·∫≠p nh·∫≠t h√†m x·ª≠ l√Ω game TicTacToe
const handleTicTacToe = (groupId, position, userId) => {
  if (!gameStates.has(groupId)) {
    gameStates.set(groupId, {
      board: Array(9).fill(null),
      currentPlayer: "X",
      players: { X: userId }
    });
    return createMessageBox(
      'üéÆ C·ªú CARO',
      `Ng∆∞·ªùi ch∆°i 1: ‚ùå
ƒêang ch·ªù ng∆∞·ªùi ch∆°i 2...

${renderBoard(Array(9).fill(null))}

C√°ch ch∆°i: G√µ !tictactoe [1-9]`,
      'üí° Ng∆∞·ªùi ch∆°i kh√°c tham gia b·∫±ng c√°ch ƒë√°nh m·ªôt n∆∞·ªõc ƒëi'
    );
  }

  const game = gameStates.get(groupId);
  
  if (game.players.O && game.players[game.currentPlayer] !== userId) {
    return createMessageBox('‚ùå KH√îNG H·ª¢P L·ªÜ', 'Kh√¥ng ph·∫£i l∆∞·ª£t c·ªßa b·∫°n!');
  }

  if (!game.players.O && userId !== game.players.X) {
    game.players.O = userId;
  }

  position = parseInt(position) - 1;
  if (position < 0 || position > 8 || game.board[position]) {
    return createMessageBox('‚ùå KH√îNG H·ª¢P L·ªÜ', 'V·ªã tr√≠ kh√¥ng h·ª£p l·ªá!');
  }

  game.board[position] = game.currentPlayer;
  const winner = checkWinner(game.board);
  
  if (winner) {
    const result = createMessageBox(
      'üéÆ K·∫æT TH√öC',
      `Ng∆∞·ªùi ch∆°i ${winner} ƒë√£ th·∫Øng!

${renderBoard(game.board)}`,
      'üéâ Ch√∫c m·ª´ng!'
    );
    gameStates.delete(groupId);
    return result;
  }

  if (game.board.every(cell => cell !== null)) {
    const result = createMessageBox(
      'üéÆ K·∫æT TH√öC',
      `H√≤a!

${renderBoard(game.board)}`,
      'ü§ù Tr·∫≠n ƒë·∫•u hay!'
    );
    gameStates.delete(groupId);
    return result;
  }

  game.currentPlayer = game.currentPlayer === "X" ? "O" : "X";
  return createMessageBox(
    'üéÆ C·ªú CARO',
    `L∆∞·ª£t c·ªßa: ${game.currentPlayer === 'X' ? '‚ùå' : '‚≠ï'}

${renderBoard(game.board)}`,
    'üí≠ ƒêang suy nghƒ©...'
  );
};

// H√†m ki·ªÉm tra ng∆∞·ªùi th·∫Øng TicTacToe
const checkWinner = (board) => {
  const lines = [
    [0, 1, 2], [3, 4, 5], [6, 7, 8], // Ngang
    [0, 3, 6], [1, 4, 7], [2, 5, 8], // D·ªçc
    [0, 4, 8], [2, 4, 6] // Ch√©o
  ];

  for (const [a, b, c] of lines) {
    if (board[a] && board[a] === board[b] && board[a] === board[c]) {
      return board[a];
    }
  }
  return null;
};

// C·∫≠p nh·∫≠t h√†m d·ªãch vƒÉn b·∫£n
const translateText = async (text, targetLang = 'vi') => {
  try {
    const [translation] = await translateClient.translate(text, targetLang);
    return translation;
  } catch (err) {
    console.error('L·ªói d·ªãch vƒÉn b·∫£n:', err);
    return null;
  }
};

// C·∫≠p nh·∫≠t h√†m x·ª≠ l√Ω sticker
const createSticker = async (imageUrl) => {
  try {
    const result = await cloudinary.uploader.upload(imageUrl, {
      transformation: [
        { width: 512, height: 512, crop: "fill" },
        { format: "webp" }
      ]
    });
    return createMessageBox(
      'üé® STICKER',
      'Sticker c·ªßa b·∫°n ƒë√£ s·∫µn s√†ng!',
      `üîó ${result.secure_url}`
    );
  } catch (error) {
    console.error("L·ªói t·∫°o sticker:", error);
    return createMessageBox('‚ùå L·ªñI', 'Kh√¥ng th·ªÉ t·∫°o sticker t·ª´ ·∫£nh n√†y!');
  }
};

// C·∫≠p nh·∫≠t h√†m x·ª≠ l√Ω QR
const handleQR = async (text) => {
  try {
    const qrUrl = await QRCode.toDataURL(text);
    return createMessageBox(
      'üì± M√É QR',
      'M√£ QR c·ªßa b·∫°n ƒë√£ s·∫µn s√†ng!',
      `üîó ${qrUrl}`
    );
  } catch (err) {
    console.error('L·ªói t·∫°o QR:', err);
    return createMessageBox('‚ùå L·ªñI', 'Kh√¥ng th·ªÉ t·∫°o m√£ QR!');
  }
};

// C·∫≠p nh·∫≠t h√†m x·ª≠ l√Ω info
const handleInfo = () => {
  return createMessageBox(
    'üè∞ MINECRAFT COMMUNITY',
    `Ch√†o m·ª´ng ƒë·∫øn v·ªõi c·ªông ƒë·ªìng Minecraft!

‚Ä¢ Chia s·∫ª ki·∫øn th·ª©c
‚Ä¢ Giao l∆∞u k·∫øt b·∫°n
‚Ä¢ C√πng nhau ph√°t tri·ªÉn

Tham gia ngay ƒë·ªÉ c√≥ nh·ªØng tr·∫£i nghi·ªám tuy·ªát v·ªùi!`,
    'üí´ Together we build, together we grow!'
  );
};

// C·∫≠p nh·∫≠t h√†m x·ª≠ l√Ω rule
const handleRule = () => {
  return createMessageBox(
    'üìú N·ªòI QUY NH√ìM',
    `1. T√¥n tr·ªçng m·ªçi ng∆∞·ªùi
2. Kh√¥ng spam, qu·∫£ng c√°o
3. Kh√¥ng share n·ªôi dung 18+
4. Kh√¥ng ch·ª≠i th·ªÅ, toxic
5. H·∫°n ch·∫ø vi·∫øt t·∫Øt
6. D√πng ti·∫øng Vi·ªát c√≥ d·∫•u
7. Gi√∫p ƒë·ª° th√†nh vi√™n m·ªõi

Vi ph·∫°m = C·∫£nh c√°o/Kick`,
    'ü§ù V√¨ m·ªôt c·ªông ƒë·ªìng vƒÉn minh!'
  );
};

// C·∫≠p nh·∫≠t h√†m x·ª≠ l√Ω l·ªánh quiz
const handleQuiz = (groupId) => {
  if (!activeGames.quiz[groupId]) {
    const randomQuestion = quizQuestions[Math.floor(Math.random() * quizQuestions.length)];
    activeGames.quiz[groupId] = {
      question: randomQuestion.question,
      answer: randomQuestion.answer.toLowerCase(),
      asked: false
    };
    
    return createMessageBox(
      '‚ùì C√ÇU ƒê·ªê MINECRAFT',
      `C√¢u h·ªèi: ${randomQuestion.question}\n\nG√µ c√¢u tr·∫£ l·ªùi c·ªßa b·∫°n!`,
      'üí° B·∫°n c√≥ 30 gi√¢y ƒë·ªÉ tr·∫£ l·ªùi!'
    );
  } else {
    return createMessageBox(
      '‚ö†Ô∏è L·ªñI',
      'ƒêang c√≥ m·ªôt c√¢u ƒë·ªë ƒëang di·ªÖn ra!\nVui l√≤ng ƒë·ª£i c√¢u ƒë·ªë k·∫øt th√∫c.',
      '‚è≥ H√£y ki√™n nh·∫´n!'
    );
  }
};

// C·∫≠p nh·∫≠t h√†m x·ª≠ l√Ω l·ªánh roll
const handleRoll = () => {
  const roll = Math.floor(Math.random() * 6) + 1;
  const emoji = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'][roll - 1];
  
  return createMessageBox(
    'üé≤ TUNG X√öC X·∫ÆC',
    `K·∫øt qu·∫£: ${emoji} ${roll}`,
    'üéØ Ch√∫c may m·∫Øn l·∫ßn sau!'
  );
};

// C·∫≠p nh·∫≠t h√†m x·ª≠ l√Ω l·ªánh 8ball
const handle8Ball = (question) => {
  const responses = [
    'Ch·∫Øc ch·∫Øn r·ªìi!',
    'Kh√¥ng th·ªÉ nghi ng·ªù!',
    'C√≥ th·ªÉ l√† nh∆∞ v·∫≠y.',
    'T·ªët h∆°n l√† kh√¥ng n√≥i.',
    'Kh√¥ng th·ªÉ ƒëo√°n tr∆∞·ªõc.',
    'H√£y h·ªèi l·∫°i sau.',
    'T·ªët nh·∫•t l√† kh√¥ng.',
    'R·∫•t nghi ng·ªù.',
    'Kh√¥ng c√≥ c∆° h·ªôi.',
    'C√≥ th·ªÉ l√† kh√¥ng.'
  ];
  
  const response = responses[Math.floor(Math.random() * responses.length)];
  const emoji = ['‚ú®', 'üåü', 'üí´', '‚≠ê', 'üå†'][Math.floor(Math.random() * 5)];
  
  return createMessageBox(
    'üé± 8 BALL',
    `C√¢u h·ªèi: ${question}\n\nTr·∫£ l·ªùi: ${emoji} ${response}`,
    'üîÆ H√£y tin v√†o s·ªë ph·∫≠n!'
  );
};

// C·∫≠p nh·∫≠t h√†m x·ª≠ l√Ω l·ªánh mcskin
const handleMCSkin = (username) => {
  return createMessageBox(
    'üéÆ MINECRAFT SKIN',
    `Skin c·ªßa ng∆∞·ªùi ch∆°i: ${username}`,
    `üîó https://mc-heads.net/skin/${encodeURIComponent(username)}`
  );
};

// C·∫≠p nh·∫≠t h√†m x·ª≠ l√Ω l·ªánh mcmob
const handleMCMob = (mobName) => {
  return createMessageBox(
    'üëæ MINECRAFT MOB',
    `Th√¥ng tin v·ªÅ mob: ${mobName}`,
    `üîó https://minecraft.wiki/images/${encodeURIComponent(mobName)}.png`
  );
};

// C·∫≠p nh·∫≠t h√†m x·ª≠ l√Ω l·ªánh mcblock
const handleMCBlock = (blockName) => {
  return createMessageBox(
    'üß± MINECRAFT BLOCK',
    `Th√¥ng tin v·ªÅ block: ${blockName}`,
    `üîó https://minecraft.wiki/images/${encodeURIComponent(blockName)}.png`
  );
};

// C·∫≠p nh·∫≠t h√†m x·ª≠ l√Ω l·ªánh mcmeme
const handleMCMeme = () => {
  const memes = [
    "https://i.redd.it/creepers-are-just-green-tnt-with-legs-v0-5v9y3j9p3z4a1.jpg",
    "https://i.redd.it/when-you-find-diamonds-but-hear-a-creeper-v0-5v9y3j9p3z4a1.jpg",
    "https://i.redd.it/minecraft-memes-v0-5v9y3j9p3z4a1.jpg",
    "https://i.redd.it/minecraft-memes-2023-v0-5v9y3j9p3z4a1.jpg"
  ];
  const randomMeme = memes[Math.floor(Math.random() * memes.length)];
  
  return createMessageBox(
    'üòÇ MINECRAFT MEME',
    'Meme ng·∫´u nhi√™n cho b·∫°n!',
    `üîó ${randomMeme}`
  );
};

// C·∫≠p nh·∫≠t h√†m x·ª≠ l√Ω l·ªánh mcmusic
const handleMCMusic = () => {
  const songs = [
    { name: "Sweden - C418", url: "https://www.youtube.com/watch?v=_3ngiSxVCBs" },
    { name: "Wet Hands - C418", url: "https://www.youtube.com/watch?v=mukiMaOSLEs" },
    { name: "Living Mice - C418", url: "https://www.youtube.com/watch?v=oGxQNQtnr6Q" },
    { name: "Mice on Venus - C418", url: "https://www.youtube.com/watch?v=DZ47H84Bc_Q" }
  ];
  const randomSong = songs[Math.floor(Math.random() * songs.length)];
  
  return createMessageBox(
    'üéµ MINECRAFT MUSIC',
    `B√†i h√°t: ${randomSong.name}
Nh·∫°c sƒ©: C418

Th∆∞·ªüng th·ª©c √¢m nh·∫°c tuy·ªát v·ªùi c·ªßa Minecraft!`,
    `üîó ${randomSong.url}`
  );
};

// C·∫≠p nh·∫≠t h√†m x·ª≠ l√Ω l·ªánh help
const handleHelp = () => {
  return 'üîó Xem danh s√°ch l·ªánh t·∫°i: https://botchathelp.netlify.app';
};